# 读书笔记

## UNIX 操作系统设计

*限于时间和篇幅，本笔记只记录重点及未掌握知识，已掌握的基础知识不再记录*

~~然而看了一下，我只掌握了第一章和第二章这种引言什么的，后面全都不懂 x~~

### 第一章 系统概貌

* 命令行中，记号 “2>” 意味着对文件描述符 2 进行输出重定向。按惯例，文件描述符 2 为标准错误文件

### 第二章 内核导言

* 文件系统具有如下结构：引导块、超级块、索引节点表、数据块；每个文件系统都有一个（可能是空的）引导块
* 仅当进程从 “核心态运行” 状态转移到 “在内存中睡眠” 状态时，内核才允许上下文切换

### 第三章 数据缓冲区高速缓冲

这一章没接触过，重点记一下

* 内核通过保持一个称为数据缓冲区高速缓冲(buffer cache)（简称高速缓冲）的内部数据缓冲区池来试图减小对磁盘的存取频率。
  * 其中，数据缓冲区高速缓冲是一个软件结构，请不要与加速主存访问的硬件高速缓冲混淆
* 一个缓冲区的数据与文件系统上一个逻辑磁盘块中的数据相对应，并且内核通过考察缓冲头部中的标识符字段来识别缓冲区内容。
  * 缓冲区是磁盘块(disk block)在主存中的备份，磁盘块的内容映射到缓冲区中
* 缓冲头部包含一个设备号字段与一个块号字段，这两个字段指明了文件系统与磁盘上的数据的块号，并且唯一地标识了该缓冲区
  * 设备号是文件系统号，而不是物理设备（磁盘）号
  * 缓冲头部也包含一个指向该缓冲区的数据数组的指针，该数组大小至少必须有磁盘块那么大
  * 缓冲头部还包含状态字节，它概括了缓冲区的当前状态

* 一个缓冲区状态是如下条件的组合：
  * 缓冲区当前为“上锁”
  * 缓冲区包含有效数据
  * 内核在把某段缓冲区重新分配出去之前必须把该缓冲区内容写到磁盘上，这一条件叫做“延迟写”(delayed write)
  * 内核当前正在从磁盘往缓冲区读信息或把缓冲区的内容写到磁盘上
  * 一个进程当前正在等候缓冲区变为闲

*注：术语 “上锁” 与 “忙” 将互换使用，正如 “开锁” 与 “闲” 将互换使用一样*

* 缓冲头部的构成：
  * 设备号
  * 块号
  * 状态
  * 指向数据区域的指针
  * 指向散列队列上的下一个缓冲区的指针
  * 指向散列队列上的前一个缓冲区的指针
  * 指向空闲表上的下一个缓冲区的指针
  * 指向空闲表上的前一个缓冲区的指针

* 内核按最近最少使用算法把数据缓存与缓冲池中：在它把一个缓冲区分配给磁盘块之后，只要不是所有其他缓冲区都在更近的时间内被使用过了，它就不能让另一磁盘块使用该缓冲区
* 当内核把一个缓冲区还给缓冲池时，它通常把该缓冲区附到空闲表的尾部。当内核从空闲表上不断地摘下缓冲区时，装有有效数据的缓冲区会越来越近地移动到空闲表的头部。因此，离空闲表的头部近的缓冲区比离空闲表的头部远的缓冲区是最近最少使用的
* 一个缓冲区总是在某个散列队列上，但是它可以在或不在空闲表中

```
算法：	getblk
输入：	文件系统号
		块号
输出：现在能被磁盘块使用的上了锁的缓冲区
{
	while (没找到缓冲区)
	{
		if (块在散列队列中)
		{
			if (块忙)	/* 第五种情况 */
			{
				sleep (等候 “缓冲区变为空闲” 事件);
				continue;	/* 回到 while 循环 */
			}
			为缓冲区标记上 “忙”;	/* 第一种情况 */
			从空闲表上摘下缓冲区;
			return (缓冲区);
		}
		else	/* 块不在散列队列中 */
		{
			if (空闲表上无缓冲区)	/* 第四种情况 */
			{
				sleep (等候 “任何缓冲区变为空闲” 事件);
				continue;	/* 回到 while 循环 */
			}
			从空闲表上摘下缓冲区;
			if (缓冲区标记着延迟写)	/* 第三种情况 */
			{
				把缓冲区异步写到磁盘上;
				continue;	/* 回到 while 循环 */
			}
			/* 第二种情况——找到一个空闲缓冲区 */
			从旧散列队列中摘下缓冲区;
			把缓冲区投入新散列队列;
			return (缓冲区);
		}
	}
}
```

本节描述在算法 `getblk` 中内核把一个缓冲区分配给磁盘块时可能出现的五种典型情况：

1. 内核发现该块在它的散列队列中，并且它的缓冲区是空闲的
2. 内核在散列队列中找不到该块，因此，它从空闲表中分配一个缓冲区
3. 内核在散列队列中找不到该块，并且，在试图从空闲表中分配一个缓冲区的时候，在空闲表中找到一个已标上了 “延迟写” 标记的缓冲区。内核必须把 “延迟写” 缓冲区的内容写到磁盘上，并分配另一个缓冲区
4. 内核在散列队列中找不到该块，并且空闲缓冲区表已空
5. 内核在散列队列中找到该块，但它的缓冲区当前为忙

当内核结束使用该缓冲区时，按照算法 brelse 释放该缓冲区：

```
算法：	brelse
输入：	上锁态的缓冲区
输出：	无
{
	唤醒正在等待 “无论哪个缓冲区变为空闲” 这一事件发生的所有进程;
	唤醒正在等待 “这个缓冲区变为空闲” 这一事件发生的所有进程;
	提高处理机执行级以封锁中断;
	if (缓冲区内容有效切缓冲区非 “旧”)
		将缓冲区送入空闲表尾部
	else
		将缓冲区送入空闲表头部
	降低处理机执行级以允许中断;
	给缓冲区解锁;
}
```

它唤醒那些因该缓冲区忙而睡眠的进程，也唤醒因空闲表上没有缓冲区而睡眠的那些进程

