# 读书笔记

## UNIX 操作系统设计

*限于时间和篇幅，本笔记只记录重点及未掌握知识，已掌握的基础知识不再记录*

~~然而看了一下，我只掌握了第一章和第二章这种引言什么的，后面全都不懂 x~~

### 第一章 系统概貌

* 命令行中，记号 “2>” 意味着对文件描述符 2 进行输出重定向。按惯例，文件描述符 2 为标准错误文件

### 第二章 内核导言

* 文件系统具有如下结构：引导块、超级块、索引节点表、数据块；每个文件系统都有一个（可能是空的）引导块
* 仅当进程从 “核心态运行” 状态转移到 “在内存中睡眠” 状态时，内核才允许上下文切换

### 第三章 数据缓冲区高速缓冲

这一章没接触过，重点记一下

#### 3.1 缓冲头部

* 内核通过保持一个称为数据缓冲区高速缓冲(buffer cache)（简称高速缓冲）的内部数据缓冲区池来试图减小对磁盘的存取频率。
  * 其中，数据缓冲区高速缓冲是一个软件结构，请不要与加速主存访问的硬件高速缓冲混淆
* 一个缓冲区的数据与文件系统上一个逻辑磁盘块中的数据相对应，并且内核通过考察缓冲头部中的标识符字段来识别缓冲区内容。
  * 缓冲区是磁盘块(disk block)在主存中的备份，磁盘块的内容映射到缓冲区中
* 缓冲头部包含一个设备号字段与一个块号字段，这两个字段指明了文件系统与磁盘上的数据的块号，并且唯一地标识了该缓冲区
  * 设备号是文件系统号，而不是物理设备（磁盘）号
  * 缓冲头部也包含一个指向该缓冲区的数据数组的指针，该数组大小至少必须有磁盘块那么大
  * 缓冲头部还包含状态字节，它概括了缓冲区的当前状态

* 一个缓冲区状态是如下条件的组合：
  * 缓冲区当前为“上锁”
  * 缓冲区包含有效数据
  * 内核在把某段缓冲区重新分配出去之前必须把该缓冲区内容写到磁盘上，这一条件叫做“延迟写”(delayed write)
  * 内核当前正在从磁盘往缓冲区读信息或把缓冲区的内容写到磁盘上
  * 一个进程当前正在等候缓冲区变为闲

*注：术语 “上锁” 与 “忙” 将互换使用，正如 “开锁” 与 “闲” 将互换使用一样*

* 缓冲头部的构成：
  * 设备号
  * 块号
  * 状态
  * 指向数据区域的指针
  * 指向散列队列上的下一个缓冲区的指针
  * 指向散列队列上的前一个缓冲区的指针
  * 指向空闲表上的下一个缓冲区的指针
  * 指向空闲表上的前一个缓冲区的指针

#### 3.2 缓冲池的结构

* 内核按最近最少使用算法把数据缓存与缓冲池中：在它把一个缓冲区分配给磁盘块之后，只要不是所有其他缓冲区都在更近的时间内被使用过了，它就不能让另一磁盘块使用该缓冲区
* 当内核把一个缓冲区还给缓冲池时，它通常把该缓冲区附到空闲表的尾部。当内核从空闲表上不断地摘下缓冲区时，装有有效数据的缓冲区会越来越近地移动到空闲表的头部。因此，离空闲表的头部近的缓冲区比离空闲表的头部远的缓冲区是最近最少使用的
* 一个缓冲区总是在某个散列队列上，但是它可以在或不在空闲表中

#### 3.3 缓冲区的检索

```
算法：	getblk
输入：	文件系统号
		块号
输出：现在能被磁盘块使用的上了锁的缓冲区
{
	while (没找到缓冲区)
	{
		if (块在散列队列中)
		{
			if (块忙)	/* 第五种情况 */
			{
				sleep (等候 “缓冲区变为空闲” 事件);
				continue;	/* 回到 while 循环 */
			}
			为缓冲区标记上 “忙”;	/* 第一种情况 */
			从空闲表上摘下缓冲区;
			return (缓冲区);
		}
		else	/* 块不在散列队列中 */
		{
			if (空闲表上无缓冲区)	/* 第四种情况 */
			{
				sleep (等候 “任何缓冲区变为空闲” 事件);
				continue;	/* 回到 while 循环 */
			}
			从空闲表上摘下缓冲区;
			if (缓冲区标记着延迟写)	/* 第三种情况 */
			{
				把缓冲区异步写到磁盘上;
				continue;	/* 回到 while 循环 */
			}
			/* 第二种情况——找到一个空闲缓冲区 */
			从旧散列队列中摘下缓冲区;
			把缓冲区投入新散列队列;
			return (缓冲区);
		}
	}
}
```

本节描述在算法 `getblk` 中内核把一个缓冲区分配给磁盘块时可能出现的五种典型情况：

1. 内核发现该块在它的散列队列中，并且它的缓冲区是空闲的
2. 内核在散列队列中找不到该块，因此，它从空闲表中分配一个缓冲区
3. 内核在散列队列中找不到该块，并且，在试图从空闲表中分配一个缓冲区的时候，在空闲表中找到一个已标上了 “延迟写” 标记的缓冲区。内核必须把 “延迟写” 缓冲区的内容写到磁盘上，并分配另一个缓冲区
4. 内核在散列队列中找不到该块，并且空闲缓冲区表已空
5. 内核在散列队列中找到该块，但它的缓冲区当前为忙

当内核结束使用该缓冲区时，按照算法 brelse 释放该缓冲区：

```
算法：	brelse
输入：	上锁态的缓冲区
输出：	无
{
	唤醒正在等待 “无论哪个缓冲区变为空闲” 这一事件发生的所有进程;
	唤醒正在等待 “这个缓冲区变为空闲” 这一事件发生的所有进程;
	提高处理机执行级以封锁中断;
	if (缓冲区内容有效切缓冲区非 “旧”)
		将缓冲区送入空闲表尾部
	else
		将缓冲区送入空闲表头部
	降低处理机执行级以允许中断;
	给缓冲区解锁;
}
```

它唤醒那些因该缓冲区忙而睡眠的进程，也唤醒因空闲表上没有缓冲区而睡眠的那些进程

#### 3.4 读磁盘块与写磁盘块

为了读一个磁盘块，进程使用算法 `getblk` 在高速缓冲中搜索这个磁盘块：

```
算法：	bread	/* 读块 */
输入：	文件系统块号
输出：	含有数据的缓冲区
{
	得到该块的缓冲区（算法 getblk）;
	if (缓冲区数据有效)
		return (缓冲区);
	启动磁盘读;
	sleep (等待 “读盘完成” 事件);
	return (缓冲区);
}
```

我们在第 5 章中将看到，当一个进程顺序地读一个文件时，较高层次的内核模块（比如文件子系统）可能会预期到对另一个磁盘块的需要，因而该模块异步地请求第二个 I/O，希望一旦需要这部分数据时，这部分数据将在主存中，这样可以改善性能

为了做到这一点，内核执行提前读磁盘块算法 `breada`；内核检查第一块是否在高速缓冲中，并且，如果它不在，则请求磁盘驱动程序读该块。如果第二块不在高速缓冲中，则内核只是磁盘驱动程序异步读它。然后，该进程去睡眠以等候 “第一个块的 I/O 完成” 时间的发生。当它醒来时，它返回第一块的缓冲区，并不关心第二块的 I/O 何时完成

当第二个块的 I/O 完成时，磁盘控制器向系统发中断，中断处理程序识别出该 I/O 是异步的，并释放该缓冲区（算法 `brelse`）。如果它不释放该缓冲区，则该缓冲区保持上锁状态，从而对于所有进程都是不可存取的。事先为缓冲区解锁是不可能的，因为对该缓冲区的 I/O 是活动的，从而该缓冲区的内容是无效的。随后，如果该进程想要读第二块，那么若 I/O 在此期间已经完成，则应该在高速缓冲中找得第二块

如果在 `breada` 开始时第一块已在高速缓冲中，则内核立即检查第二块是否也在高速缓冲中，并且按以上描述的那样执行

```
算法：	breada	/* 读块与提前读 */
输入：	立即读的文件系统块号
		异步读的文件系统块号
输出：	含有可立即读的数据缓冲区
{
	if (第一块不在高速缓冲中)
	{
		为第一块获得缓冲区（算法 getblk）;
		if (缓冲区数据无效)
			启动磁盘读;
	}
	if (第二块不在高速缓冲中)
	{
		为第二块获得缓冲区（算法 getblk）;
		if (缓冲区数据有效)
			释放缓冲区（算法 brelse）;
		else
			启动磁盘读;
	}
	if (第一块本来就在高速缓冲中)
	{
		读第一块（算法 bread）;
		return (缓冲区)
	}
	sleep (第一个缓冲区包含有效数据的事件);
	return (缓冲区);
}
```

在某些场合下，内核并不立即地把数据写到磁盘上。如果执行这样的一个延迟写，则它相应地为该缓冲区做标记，使用 `brelse` 算法释放该缓冲区，并且不调度 I/O 就继续向下执行：

```
算法：	bwrite	/* 写块 */
输入：	缓冲区
输出：	无
{
	启动磁盘写;
	if (I/O 同步)
	{
		sleep (等待 “I/O” 完成事件);
		释放缓冲区（算法 brelse）;
	}
	else if (缓冲区标记着延迟写)
		为缓冲区做标记以放到空闲表头部;
}
```

#### 3.5 高速缓冲的优点与缺点

高速缓冲的优点：

* 缓冲区的使用提供了统一的磁盘存取方法，因为内核不需要知道 I/O 的原因
* 系统对进行 I/O 的用户进程没有做数据对齐限制，因为内核在内部实现了数据对齐（这个不太懂）
* 高速缓冲的使用可减少访盘次数，从而提高整个系统的吞吐量，减少响应时间
* 缓冲区算法有助于确保文件系统的完整性，因为它们维护一个公共的、包含在高速缓冲中的磁盘块的单一映像

高速缓冲的缺点：

* 由于延迟写使得内核没有立即地把数据写到磁盘上，因此，当系统发生瘫痪使磁盘数据处于错误状态时，系统显得无能为力
* 高速缓冲的使用，使得当往用户进程中读或从用户进程写时需要一次额外的数据拷贝过程

### 第四章 文件的内部表示

本章描述的算法所在的层次居于上一章所解释的高速缓冲算法之上

* 算法 `iget` 返回一个先前标识了的索引节点
* 算法 `iput` 释放索引节点
* 算法 `bmap` 为存取一个文件设置内核参数
* 算法 `namei` 使用算法 `iget`, `ipupt` 及 `bmap` 把一个用户级路径名转换成一个索引节点
* 算法 `alloc` 与 `free` 为文件分配及释放 磁盘块
* 算法 `ialloc` 与 `ifree` 为文件分配及释放索引节点

#### 4.1 索引节点

磁盘索引节点由如下字段组成：

* 文件所有者标识号
* 文件类型
* 文件存取许可权
* 文件存取时间
* 文件联结数目
* 文件数据的磁盘地址明细表
* 文件大小

内存中的索引节点拷贝除了磁盘索引节点所包含的那些字段外，还包含如下字段：

* 内存索引节点的状态，它指示：
  * 索引节点是否被上锁了
  * 是否有进程正在等待索引节点变为开锁状态
  * 作为对索引节点中的数据进行更改的结果，索引节点的内存表示是否与它的磁盘拷贝不同
  * 是否该文件为安装点（见 5.15 节）
* 含有该文件的文件系统的逻辑设备号
* 索引节点号
* 指向其他内存索引节点的指针
* 引用数

算法 `iget` 分配一个索引节点的内存拷贝，它与为在高速缓冲中找到一个磁盘块的 `getblk` 算法几乎是完全相同的：

```
算法：	iget
输入：	文件系统索引节点号
输出：	上锁状态的索引节点
{
	while (未完成)
	{
		if (是索引节点高速缓冲中的索引节点)
		{
			if (索引节点为上锁状态)
			{
				sleep (索引节点变成开锁状态事件);
				continue;	/* 循环回到 while */
			}
			/* 对安装点进行特殊处理（第 5 章） */
			if (是空闲索引节点表上的索引节点)
				从空闲表上移去该节点;
			索引节点引用计数增值 1;
			return (索引节点);
		}

		/* 不是索引节点高速缓冲装的索引节点 */
		if (空闲表上没有索引节点)
			return (错误);
		从空闲表上移出一个新索引节点;
		重置索引节点号及文件系统;
		从老的散列队列中撤掉索引节点，把索引节点放到新的散列队列中;
		从磁盘上读索引节点（算法 bread）;
		索引节点初始化（例如访问计数置为 1）;
		return (索引节点);
	}
}
```

块号 = ((索引节点号-1) / 每块的索引节点数目) + 索引节点表的起始块号

当内核知道了设备和磁盘块号时，它使用算法 `bread` 读出该块，然后使用下述公式计算本索引节点在该块中的字节偏移量：

((索引节点号-1) mod (每块的索引节点数目)) * 磁盘索引节点大小

# 学习笔记

## 哈工大 计算机组成原理

想起找工作面试的时候面试官问了我几个 Cache 相关的问题，我都没答上来，特地回来补补

### 4.3 高速缓冲存储器

#### 一 概述

##### 1. 为什么用 Cache

* 避免 CPU “空等” 现象
* CPU 和 主存（DRAM）的速度差异
* 程序访问的局部性原理

##### 2. Cache 的工作原理

* 主存和缓存的编址
  * 主存（M 位）：主存块号（m 位） + 块内地址（b 位）
  * 缓存（C 块）：缓存块号（c 位） + 块内地址（b 位）
  * 主存和缓存按块存储，块的大小相同
* 命中与未命中
  * 缓存有 C 块，主存有 M 块，M >> C
  * 命中：主存块调入缓存，主存块与缓存块建立了对应关系
  * 未命中：主存块未调入缓存，主存块与缓存块未建立对应关系
  * 用标记记录与某缓存块建立了对应关系的主存块号
* Cache 的命中率
  * CPU 欲访问的信息在 Cache 中的比率
  * 命中率与 Cache 的容量及块长有关
  * 一般每块可取 4~8 个字
  * 块长取一个存取周期内从主存调出的信息长度
  * CRAY\_1 16体交叉 块长取 16 个存储字
  * IBM 370/168 4体交叉 块长取 4 个存储字（64 位 \* 4 = 256 位）
* Cache - 主存系统的效率
  * 效率 e 与 命中率 有关
  * e = 访问 Cache 的时间 / 平均访问时间
  * 设 Cache 命中率为 h，访问 Cache 的时间为 t\_c，访问主存的时间为 t\_m
  * 则 e = t\_c / (h\*t\_c + (1-h)\*t\_m)

##### 3. Cache 的基本结构

##### 4. Cache 的读写操作

* 读
* 写：Cache 和只存的一致性
  * 写直达法（Write-through）
    * 写操作时数据既写入 Cache 又写入主存
	* 写操作时间就是访问主存的时间
	* Cache 块退出时不需要对主存执行写操作，更新策略比较容易实现
  * 写回法（Write-back）
    * 写操作只把数据写入 Cache 而不写入主存
	* 当 Cache 数据被替换出去时才写会主存

##### 5. Cache 的改进

1. 增加 Cache 的级数
   * 片载 Cache；片外 Cache
2. 统一缓存和分立缓存
   * 指令 Cache 和 数据 Cache
   * 与指令执行的控制方式有关 是否流水
   * Pentium 8K 指令 Cache，8K 数据 Cache
   * PowerPC620 32K 指令 Cache，32K 数据 Cache

#### 二 Cache - 主存的地址映射

##### 1. 直接映射

把主存分区，以 Cache 大小为一个区

##### 2. 全相联映射

##### 3. 组相联映射

#### 三 替换算法

