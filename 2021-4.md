## Day 91 2021-04-01

不知不觉就到了四月了呢，今天难得不忙

同一个实验室做毕业论文的同学们都复试完了，然而实验室做实验的设备不够用，所以老师让我们轮流去，我昨天去了今天就可以休息了x

今天补了下哈工大的计组，复习了下 Cache 的相关内容

后天就该打 ICPC 区域赛了，这两天先认真刷题吧，打完再搞 OSCOMP

## Day 92 2021-04-02

做实验，打热身赛，表现一般

## Day 93 2021-04-03

昆明站发的衣服不错

这次尽力了，256 名。这次比赛 800+ 队伍，但是只发 210 个牌子，太卷了点也

今天比较累了，先咕了吧，不过最近咕得也确实有点多了x

明天后天还想出去玩(x)，过完清明假期继续肝吧

## Day 94 2021-04-04

出去玩，咕咕咕

## Day 95 2021-04-05

出去玩，咕咕咕

## Day 96 2021-04-06

做了一天实验，明天实验室老师有事，可以继续折腾 GeeOS 了，整一下 `sys_fork` 试试看

另外，今天出昆明站 ICPC 最终榜单了，去掉打星的队伍后 243 名，差一点摸到铜牌，有点遗憾

害，过去就过去了，好好搞 OSCOMP 吧

## Day 97 2021-04-07

写了一天的 bug，由于 GeeOS 的代码太久没看了，而且页表相关的代码我也没有很深入研究过，所以进展比较慢

不过现在对页表啥的有了更深的理解了，不错

## Day 98~100 2021-04-10

做实验，刷题，摸鱼

## Day 101 2021-04-11

写了一天的 bug，写 fork 的时候 PPN 那边老是出问题...

然后，晚上出去玩，咕咕咕 x

## Day 102 2021-04-12

昨天折腾了很久都没想到问题出在哪，今天稍加思考，一下子就意识到：

我抄的是 rCore-Tutorial 的代码，而 rCore-Tutorial 是 RV64 的，用的是 Sv39 的页表，而 GeeOS 是 RV32 的，用的是 Sv32 的页表

怪不得出错

## Day 103 2021-04-13

完成了 `MemorySet` 的 `fromExistUser` 功能，fork 也能正常进行了，但是切换到 fork 出的线程后会发生 PageFault，明天再 debug 吧

## Day 104 2021-04-14

fork 勉强完成了，但是数据段似乎炸了...

我写的 fork 小程序代码是这样的：

```
import lib.io
import lib.sys.syscall

extern def main(argc: i32, argv: u8**): i32 {
  let ret = fork()
  let pid = getPid()
  io <<< "fork's return is " <<< ret <<< ", pid is " <<< pid <<< '\n'
  0
}
```

运行后的结果是这样的：

```
Welcome to GeeOS shell!
$ fork
fork's return is 2, pid is 2
�#&#&�0�#&#&�3
$
```

而应该得到的输出是这样的：

```
Welcome to GeeOS shell!
$ fork
fork's return is 2, pid is 2
fork's return is 0, pid is 3
$
```

应该是 `.rodata` 段没复制导致的

输出了一下，发现是复制页的范围出了点问题，开始和结束的 vpn 应该是一个闭区间，我给整成前闭后开的区间了，导致每个段都少复制了一页，解决掉这个问题后，fork 目前看起来一切正常

又改了下 fork 小程序的代码，让程序反复 fork 多次，问题又出现了：

```
Welcome to GeeOS shell!
$ fork
first fork's return is 2, pid is 2
second fork's return is 2, pid is 2
third fork's return is 2 pid is 2
first fork's return is 0, pid is 3
second fork's return is 3, pid is 3
third fork's return is 3 pid is 3
second fork's return is 0, pid is 4
third fork's return is 4 pid is 4
third fork's return is 0 pid is 5
$
```

显然少了好几个线程

在 `addThread` 的地方加了几个输出，发现了问题：

```
Welcome to GeeOS shell!
$ fork
addThread: pid = 2
addThread: pid = 3
first fork's return is 2, pid is 2
addThread: pid = 4
second fork's return is 2, pid is 2
addThread: pid = 5
third fork's return is 2 pid is 2
first fork's return is 0, pid is 3
addThread: pid = 6
second fork's return is 3, pid is 3
addThread: pid = 7
third fork's return is 3 pid is 3
second fork's return is 0, pid is 4
addThread: pid = 8
third fork's return is 4 pid is 4
third fork's return is 0 pid is 5
$
```

fork 进程似乎一切正常，而且线程都添加到线程池里了，但是似乎调度的时候出了点问题

## Day 105 2021-04-15

改了下 `pool.yu` 的代码，给 `add` 和 `retrieve` 加了输出，观察一下：

```
Welcome to GeeOS shell!
$ fork
	push tid: 1, pid: 2
	push tid: 2, pid: 3
first fork's return is 2, pid is 2
	push tid: 3, pid: 4
second fork's return is 2, pid is 2
	push tid: 4, pid: 5
third fork's return is 2 pid is 2
	release tid: 1, pid: 2
first fork's return is 0, pid is 3
	push tid: 1, pid: 6
second fork's return is 3, pid is 3
	push tid: 5, pid: 7
third fork's return is 3 pid is 3
	release tid: 2, pid: 3
second fork's return is 0, pid is 4
	push tid: 2, pid: 8
third fork's return is 4 pid is 4
	release tid: 3, pid: 4
third fork's return is 0 pid is 5
	release tid: 4, pid: 5
$
```

显然，tid=1 pid=6，tid=5 pid=7，tid=2 pid=8 的线程都没有运行，不知道是哪里的问题

## Day 106~109 2021-04-16~2021-04-19

做实验，肝算法比赛，甚至都有点怀疑这个项目我能不能做完...

明天比较闲，深入研究一下调度器吧

## Day 110 2021-04-20

我给所有的 `scheduler.push` 和 `scheduler.pop` 都加了输出来观察结果，发现问题所在了，这里只截取一部分：

```
second fork's return is 3, pid is 3
	push tid: 5, pid: 7
	thread list: 4 5 1 2 6 0
third fork's return is 3 pid is 3
	wakeup push tid: 0, pid: 1
	thread list: 4 5 1 0
```

需要说明的是，因为 `scheduler.threads[0]` 是用来存队首和队尾的，并不是一个有效的线程，而线程的 tid 是有 `0` 的，所以在放入队列的时候将所有的 tid 都加了 1

在这里，队列中的线程本为：`3 4 0 1 5`，后面的过程试图唤醒线程 0，即将其从挂起态转为就绪态，然后放至队尾

但是由于线程 0 本就已经存在，这里的代码并没有预料到这一点，而将其强行设为队尾，导致队列的链表被截断

不过我也好奇，为什么一个没有被挂起的线程会被 wakeUp 呢？

又深入调查了一下，是我的锅（）

我创建 fork 线程的时候把线程的 `wait` 设为了 0，改成 `TID_NONE` 就好了，调度器本身并没有问题

修改后的正常输出结果：

```
Welcome to GeeOS shell!
$ fork
first fork's return is 2, pid is 2
second fork's return is 2, pid is 2
third fork's return is 2 pid is 2
first fork's return is 0, pid is 3
second fork's return is 3, pid is 3
third fork's return is 3 pid is 3
second fork's return is 0, pid is 4
third fork's return is 4 pid is 4
third fork's return is 0 pid is 5
$ second fork's return is 0, pid is 6
third fork's return is 6 pid is 6
third fork's return is 0 pid is 7
third fork's return is 0 pid is 8
third fork's return is 0 pid is 9
```

还有一点小问题就是，GeeOS 中并不支持标准的 `sys_exec`，现在的 `sys_exec` 相当于 `spawn` 的作用，而 GeeOS 中的 shell 在执行的进程结束后就输出 `$` 符号了，导致会提前输出

要解决这个问题，需要实现标准的 `sys_exec` 和 `sys_wait`，我简单写一下吧

除此之外，关于 fork 效率低的问题，现在比较常用的解决方法是使用 copy-on-write 技术，fork 时先不复制内存，而是让子进程的内存指向父进程的内存，等到父进程需要修改内存之前再复制给子进程，因为子进程 fork 之后一般是直接执行 exec 的，这样子的话本身是不需要复制内存空间的，可以节省一定的开销

但是 copy-on-write 需要对父进程写内存的操作进行监控吧，这一点我还不知道怎么做，查下资料先，或者先战术放弃 (x

改了一下 `Thread` 的 `wait`，问题解决了，然后编译了下 rv32ima 的 busybox，开始尝试移植！

